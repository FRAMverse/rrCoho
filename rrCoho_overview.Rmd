---
title: "rrCoho overview"
author: "Dan.Auerbach@dfw.wa.gov"
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
output: 
  bookdown::html_document2:
    self_contained: true
    fig_caption: yes
    theme: flatly
    toc: yes
    toc_depth: 3
    toc_float: yes
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 9)

library("tidyverse")
library("gt")

library("framr")

lu <- list(
  crc_fram = as_tibble(framr::lu_coho_crc_fram),
  tocas_fram = as_tibble(framr::lu_coho_tocas_fram),
  #fishtix_fram?
  #rmis_fram_fishery = readr::read_csv("https://raw.githubusercontent.com/PSC-CoTC/coho_CWT_analysis/main/lu_ahb_FishMap_20220826.csv")
  rmis_fram_fishery = readr::read_csv("lu_ahb_FishMap_20220826.csv") |> 
    filter(Num_Chars > 0) |> 
    select(FisheryID, FisheryName, fishery_single = Gear, Num_Chars, PSC_Code) |>
    distinct(FisheryID, FisheryName, fishery_single, Num_Chars, PSC_Code),
    
  fram_ca = readr::read_csv("lu_FRAM_CA.csv"),
  ca_pr_mu = readr::read_csv("lu_CA_PR_MU.csv")
)

#lu$tocas_fram <- readxl::read_excel("O:/code/framr/xlsx/lu_coho.xlsx", sheet = "TOCAS_FRAM")
#lu$fram_ca <- readr::read_csv("lu_FRAM_CA.csv")

data_in <- list()

# params:
#   file_escp:
#     - target version of CoTC escapement compilation file? Not yet a function since just a simple readxl
#   file_crc:
#     - target sport harvest mdb; this can/should change if/when a directly query-able resource becomes available
#   file_tocas:
#     - target for TOCAS query dataset


mb20 <- list()
mb20$escp <- read_csv("O:/code/coho/rrterm/MB_Draft_2020/Data_ProcessingSteps/Escapement_Inputs/MU_Escapement_013122.csv")
mb20$crc <- read_csv("O:/code/coho/rrterm/MB_Draft_2020/Data_ProcessingSteps/Landings_Sport/RRTerm_CA_Catch_FinalInputSpt_RegularTS_012722.csv")
mb20$tocas <- read_csv("O:/code/coho/rrterm/MB_Draft_2020/Data_ProcessingSteps/Landings_Commercial/RRTerm_CA_Catch_CommFinalwNames_RegularTS_121621.csv")

```


https://fisheriesservices.nwifc.org/fram-model-runs/preseason-fram-model-preparation/salmon-run-reconstruction-puget-sound/

-CWT assignment is to FRAM units first
  - fishery via rec_loc_code
  - stock via ...? RMIS fields of some sort
-Fisheries sequential within PR?!? (turns out no)
-user choice to alter flagging for use of CWTs --> actually this is the "sequential" aspect, moving in from pre-terminal
  -MB codified ruleset for when to "turn-off"
-MSFs require "tricking" via small PEF (fishery-year specific based on regs) values of 0.0001
  -MB suggest improving this, perhaps via something like an MSF flag
  -this may have been the point at which 2006 Packer development stalled? Due to lack of marked-catch data 
-recall HC is copy-paste from regional Cindy Gray RR


# Established lookups

```{r read_rrterm_mdb, eval=FALSE}
#db <- "O:/code/coho/rrterm/CohoRR_4_CoManagerReview_020221/RRT_CO_2019-10_2021-02-02.mdb"
db <- "O:/code/coho/rrterm/CohoRR_4_CoMngrReview_wHC_013122/RRT_CO_2020-10_2022_01_31rv.mdb"

db_con <- DBI::dbConnect(drv = odbc::odbc(), .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=", db, ";"))

rr <- list(
  lu_pr = "PR_Data", #stock "production regions"
  lu_mu = "MU_Data", #stock "management units" within production regions
  lu_ca = "CA_Data", #"catch areas"
  lu_ca_mu = "CA_MU_Table", #cross-ref
  
  pef = "MU_Local_PEF", #what makes field "Local_PEF" and where is it used?
  qval = "MU_PR_Qval", #what is field "Qvalue" and where is it used?
  hr_scaler = "MU_HR_Scaler", #what makes field "HR_Value" and where is it used?
  cwt = "CWT_Rec", #recoveries of CWTs indexed by CA and MU_Short_Name but not PR & PR_MU
  
  hvst = "CA_Catch",
  escp = "MU_Escapement",
  
  run_calc_saved = "Run_Calc_Saved" #appears to be output matching xlsx
) |> 
  map(~collect(tbl(db_con, .x)))

DBI::dbDisconnect(db_con)

```

```{r write_lu_csvs, eval=FALSE}
rr$lu_mu

# #looking at missing TR portion of paired FisheryIDs
# rr$lu_ca |> filter(CA_Number == 505); lu$tocas_fram |> filter(between(FisheryID, 82, 83))
# rr$lu_ca |> filter(CA_Number == 531)
# rr$lu_ca |> filter(CA_Number == 561)
# rr$lu_ca |> filter(CA_Number == 581)
# rr$lu_ca |> filter(CA_Number == 583)
# rr$lu_ca |> filter(CA_Number == 611)
# rr$lu_ca |> filter(CA_Number == 614)
# rr$lu_ca |> filter(CA_Number == 615)
# rr$lu_ca |> filter(CA_Number == 651)
# rr$lu_ca |> filter(CA_Number == 656); lu$tocas_fram |> filter(between(FisheryID, 141, 142))
# rr$lu_ca |> filter(CA_Number == 657); lu$tocas_fram |> filter(between(FisheryID, 143, 144))
# rr$lu_ca |> filter(CA_Number == 705); lu$tocas_fram |> filter(between(FisheryID, 153, 154))
# rr$lu_ca |> filter(CA_Number == 706); lu$tocas_fram |> filter(between(FisheryID, 155, 156))
# rr$lu_ca |> filter(CA_Number == 709); lu$tocas_fram |> filter(between(FisheryID, 157, 158))
# rr$lu_ca |> filter(CA_Number == 710); lu$tocas_fram |> filter(between(FisheryID, 159, 160))
# 
# 
# #mapping FRAM FisheryIDs to RRterm CA catch areas
# #now added MB FW/M RRTermType field to define which FRAM timesteps used in aggregation to annual
# rr$lu_ca |>
#   bind_rows(
#     rr$lu_ca |> filter(CA_Number == 505) |> mutate(FRAM_CA_Number = 83), #A6DTr missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 531) |> mutate(FRAM_CA_Number = 97), #Tr 7BCD missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 561) |> mutate(FRAM_CA_Number = 102), #Tr Skag Net missing but catches exist for FRAM f102
#     rr$lu_ca |> filter(CA_Number == 581) |> mutate(FRAM_CA_Number = 110), #Tr A8A Net missing but catches exist for FRAM f110
#     rr$lu_ca |> filter(CA_Number == 583) |> mutate(FRAM_CA_Number = 112), #Tr A8D Net missing but catches exist for FRAM f112
#     rr$lu_ca |> filter(CA_Number == 611) |> mutate(FRAM_CA_Number = 120), #Tr A10 Net missing but catches exist for FRAM f120
#     rr$lu_ca |> filter(CA_Number == 614) |> mutate(FRAM_CA_Number = 122), #Tr A10A Net missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 615) |> mutate(FRAM_CA_Number = 124), #Tr A10E Net missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 651) |> mutate(FRAM_CA_Number = 138), #Tr A13 Net missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 656) |> mutate(FRAM_CA_Number = 142), #Tr A13A Net missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 657) |> mutate(FRAM_CA_Number = 144), #Tr A13D Net missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 705) |> mutate(FRAM_CA_Number = 154), #Tr 12-12B Net missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 706) |> mutate(FRAM_CA_Number = 156), #Tr 9-9A Net missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 709) |> mutate(FRAM_CA_Number = 158), #Tr 9-9A Net missing but catches exist
#     rr$lu_ca |> filter(CA_Number == 710) |> mutate(FRAM_CA_Number = 160) #Tr 9-9A Net missing but catches exist
#   ) |>
#   select(FisheryID = FRAM_CA_Number, CA_Number, CA_Short_Name, CWT_Flag, Cat_Flag, Type_Calc) |>
#   left_join(
#     read_csv("O:/code/coho/rrterm/MB_Draft_2020/ReferenceFiles_4Rcode/Fishery_CohoFRAM_wType_101018.csv") |>
#       select(FisheryID, RRTermType),
#     by = "FisheryID"
#   ) |>
#   write_csv("lu_FRAM_CA.csv")


# #mapping RRterm fishery CAs to stock PR+PR_MU
# #the key crosswalk to assign catches to associated stocks
# rr$lu_ca_mu |> 
#   mutate(PR_MU = paste(PR_Number, PR_MU_Number, sep = "_")) |> 
#   write_csv("lu_CA_PR_MU.csv")

```

# Escapement

expects/relies on current format of *fram_coho_escapement_YEAR.xlsx* file

reads 'dataset' sheet and wrangles to 'RRTerm' summarization by PR + PR_MU

easily modified if replacement maintains comparable "view" of PR & PR_MU fields per escapement estimate value

but underlying compilation of values in 'dataset' only partially scriptable; see fram_coho_escapement_2022.R for hatchery queries etc.

```{r read_escp}
data_in$escp <- readxl::read_excel(
  path = "copy_of_fram_coho_escapement_2022.xlsx",
  sheet = "dataset"
)|> 
  group_by(year, RRTerm_PR, RRTerm_PR_MU) |> 
  summarise(escp = sum(escp_val, na.rm = T), .groups = "drop") |> 
  mutate(
    PR_MU = paste(RRTerm_PR, RRTerm_PR_MU, sep = "_"),
    across(c(year, escp), as.integer)
    )
```

Good agreement with what appears to be MB final "RRTerm input".

  - Willapa numbers updated 2/7/22 in course of WB forecast, after MB ran 1/31/22
  - Quilcene H, Makah H, Quin H values from Carrie Cook-Tabor; also "hoodsh"? But having placeholder 0s in template ensured these were not new/NA from my file
  - Elwha was a late-changing regional conversation; need to check exactly what was agreed final with Jenni W as DA may not have all emails

```{r compare_escp}
full_join(
  data_in$escp |> filter(year == 2020),
  mb20$escp,
  by = c("RRTerm_PR" = "PR_Number", "RRTerm_PR_MU" = "PR_MU_Number")
  ) |> 
  filter(is.na(escp) | is.na(Escapement) | abs(escp - Escapement) > 1)

```

# Catches

Hopefully some/all of this gets revised to query the combined data source ("HarvestCube") project from JohnChen/Eric K/Brodie?

## Recreational: CRC

```{r read_crc_coho}
#readRDS("T:/DFW-Salmon Mgmt Modeling Team - General/Catch datasets/CRC/d_spt_hvst_est_20220302.rds")

db_crc <- "T:/DFW-Salmon Mgmt Modeling Team - General/Catch datasets/CRC/Sport Harvest Estimates 20220302.mdb"
db_con <- DBI::dbConnect(drv = odbc::odbc(), .connection_string = paste0("Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=",db_crc,";"))

data_in$crc <- dplyr::left_join(
  dplyr::collect(dplyr::tbl(db_con, "Catch")) |> 
    dplyr::mutate(dplyr::across(ends_with("Date"), ~as.Date(., format = "%m/%d/%Y"))) 
  , 
  dplyr::collect(dplyr::tbl(db_con, "Area"))
  ,
  by = "AreaID") |> 
  dplyr::rename_with(.fn = tolower) |> 
  filter(species == "Coho", areacode != "192") |> 
  mutate(
    area_code = str_pad(areacode, width = 2, pad = "0"),
    #confirmed MB comment that 9 records in 2007 & 2008 were NA but all first week of Jan
    #assign from catchperiodstartdate
    catchstatmonth = if_else(is.na(catchstatmonth), as.integer(format(catchperiodstartdate, '%m')), catchstatmonth)
    ) |>
  group_by(area_code, areaname, year = catchyear, catchstatmonth) |> 
  summarise(catchest = sum(catchest), .groups = "drop") |> 
  mutate(
    m = factor(month.abb[catchstatmonth], levels = month.abb),
    ts = case_when(
      m %in% month.abb[1:6] ~ 1,
      m == "Jul" ~ 2,
      m == "Aug" ~ 3,
      m == "Sep" ~ 4,
      m %in% month.abb[10:12] ~ 5)
    )

DBI::dbDisconnect(db_con)

```

**Notes from CohoFRAM_PostSeasonwMZ_RR_SportFisheryInputs_111021.R**

Persisted removal of AreaCode == 192 and/but could/should also be handled via LU on desired CAs? `rr$lu_ca_mu`

Persisted Timestep based on `catchstatmonth` ignoring start/end dates outside single month

Persisted CRC~FRAM LU as assigned. Migrated assignment to `framr::lu_coho_crc_fram`

```{r assign_crc_fram_id}
data_in$crc <- dplyr::left_join(
  data_in$crc,
  dplyr::select(lu$crc_fram, -FisheryID_alt),
  by = "area_code")
  #rrCoho::assign_fram_fishery_to_crc(data_in$crc)

##unassigned
#data_in$crc |> filter(is.na(FisheryID)) |> count(area_code, areaname) |> arrange(area_code) |> print(n=100)

```

Assign RRTerm CA from FRAM FisheryID

Catches only summed from FRAM timestep 3+4+5 FW or 4+5 Marine (Aug+Sep+Oct-Nov).

Seems undesirable to DA, but persisting per AHB. Apparently "dip-in" concerns.

Near exact agreement, differences almost certainly related to using newer CRC.

```{r compare_crc}
#maintaining FW 3+4+5, M 4+5 per AHB, but would prefer not to exclude pre-Aug catch on basis of 'dip in' concerns
#no idea how CWT_Flag, Cat_Flag, Type_Calc are used
data_in$crc |> 
  drop_na(FisheryID) |> 
  inner_join(lu$fram_ca, by = "FisheryID") |> 
  drop_na(RRTermType) |> 
  filter(ts > 2) |> 
  group_by(year, FisheryID, CA_Number, CA_Short_Name, CWT_Flag, Cat_Flag, Type_Calc, RRTermType, ts) |> 
  summarise(catchest = sum(catchest), .groups = "drop") |> 
  pivot_wider(names_from = ts, values_from = catchest, values_fill = 0) |> 
  mutate(
    catch = case_when(
      RRTermType == "FW" ~ `3` + `4` + `5`,
      RRTermType == "M" ~ `4` + `5`
    )
  ) |> 
  filter(year == 2020) |> 
  left_join(
    mb20$crc |> filter(Run_ID == 2020),
    by = "CA_Number"
  )

```

## Commercial: TOCAS

**Notes from CohoFRAM_PostSeason_RR_CommCatchInputs_MB121621**

>#######################################################################################
#TO QUERY RAW DATA (http://access.nwifc.org/webapps/index.asp)
#In Tribal Online Accounting System (TOCAS) interface, the query is structured as follows:
>#Biological Reports
>#TOCAS/WAFT
#Breaks: SpeciesName, Fishery, Gear, GearName, Catch Area, Disposition, Landing Date, Tribe Name.
#Select - TOCAS Filled with WAFT Data
#Values:  Select - Units
#Criteria:
# Species Selected =  
# 004 - COHO
# 044 - COHO AQUACULTURE (Note: no results, but keep in query to see if any show-up....)
# (Do not include 874 - COHO EGGS)
# Tribes Selected = ALL
# Gears Selected = ALL
# Areas Selected = ALL
# Disposition Selected = ALL
# Dealers Selected = ALL
# 
# Begin Date = 01/01/1986,  End Date = 12/31/2020  (modify as needed)
#Save the raw data in a .csv file on your computer.

Unfortunately, do not appear to actually have original raw TOCAS data: "mbellman_PostSeasCatchInputFina_12_16_2021.csv"

EDA on test version of this pretty open ended query run by Ty + Maria

```{r read_tocas}
data_in$tocas <- read_csv("O:/code/coho/rrterm/tocas_coho_2000-present.csv") |> 
  filter(Disposition %in% c("C&SF", "COMM", "ORGN", "TEST","TKHM")) |> 
  mutate(
    landing_date = as.Date(Landing_Date, format = "%m/%d/%Y"),
    month = lubridate::month(landing_date),
    year = lubridate::year(landing_date),
    ts = case_when(
      month %in% 1:6 ~ 1,
      month == 7 ~ 2,
      month == 8 ~ 3,
      month == 9 ~ 4,
      month %in% 10:12 ~ 5)
  )

#data_in$tocas |> filter(is.na(landing_date) | is.na(month) | is.na(year))
#any(nchar(data_in$tocas$Catch_Area) < 2)
#data_in$tocas |> count(Disposition)
```

Reasonable agreement where fisheries/CAs are not dropped...need to work on LU for dropped fisheries/CAs

```{r compare_tocas}
data_in$tocas |> 
  group_by(year, ts, Fishery, TribeName, Gear, Disposition, Catch_Area) |> 
  summarise(catch = sum(Units), .groups = "drop") |> 
#However, TribeName may need this soln? unique(lu_coho_tocas_fram$TribeName)
  mutate(
    #Disposition = if_else(Disposition %in% c("TEST", "Test", "C&SF"), Disposition, NA_character_),
    TribeName = if_else(TribeName %in% c("QUINAULT - 18", "CHEHALIS - 02"), TribeName, NA_character_)
  ) |> 
  left_join(
    lu$tocas_fram |> separate_rows(Disposition) |> separate_rows(Gear) |> mutate(Gear = as.integer(Gear)),
    by = c("Fishery", "TribeName", "Gear", "Disposition", "Catch_Area")
  ) |> 
  drop_na(FisheryID) |> 
  inner_join(lu$fram_ca, by = "FisheryID") |> 
  drop_na(RRTermType) |> 
  filter(ts > 2) |> 
  #group_by(year, FisheryID, CA_Number, CA_Short_Name, CWT_Flag, Cat_Flag, Type_Calc, RRTermType, ts) |> 
  group_by(year, CA_Number, CA_Short_Name, CWT_Flag, Cat_Flag, Type_Calc, RRTermType, ts) |> 
  summarise(catch = sum(catch), .groups = "drop") |> 
  arrange(year, CA_Number, ts) |> 
  pivot_wider(names_from = ts, values_from = catch, values_fill = 0) |> 
  mutate(
    catch = case_when(
      RRTermType == "FW" ~ `3` + `4` + `5`,
      RRTermType == "M" ~ `4` + `5`
    )
  ) |> 
  filter(year == 2020) |> 
  full_join(
    mb20$tocas |> filter(Run_ID == 2020) |> select(year = Run_ID, CA_Number, CA_Short_Name, Catch),
    by = c("year", "CA_Number")
  ) |> 
  mutate(d = catch - Catch) |> print(n=40)



lu$tocas_fram |> filter(FisheryID %in% c(155, 156))
data_in$tocas |> 
  group_by(year, ts, Fishery, TribeName, Gear, Disposition, Catch_Area) |> 
  summarise(catch = sum(Units), .groups = "drop") |> 
  filter(year == 2020, str_detect(Catch_Area, "6D"))

```


## Commercial: FishTicket

MB appears to have used TOCAS exclusively.

```{r ft_pull, eval=FALSE}
#con_ft <- assign connection here

#Not limited to PS commercial in FRAM - various ColR and coastal catches...
ft_pull <- inner_join(
  tbl(con_ft, dbplyr::in_schema(schema = "Reporting", table = "vFishTicketCat2")),
  tbl(con_ft, dbplyr::in_schema(schema = "Reporting", table = "vFishTicketDetailCat2"))
  , by = c("FishTicketID")
  ) |> 
  filter(
    ReleaseStatus == "Completed",
    MarketSpeciesCategoryName == "COHO",
    BatchYear >= 2015, 
    LegalAuthoritySourceCode != "impt",
    LegalAuthoritySourceCode != "invo",
    LegalAuthoritySourceCode != "aqua"
  ) |> 
  group_by(
    BatchYear, LandingMonth,
    CatchAreaCode, CatchAreaDescription,
    FisherTypeDescription, GearCode
  ) |> 
  summarize(rc = sum(ReportedCount), .groups = "drop") |>  #server-side '.group = "drop"' not working; adds a new field "group" and retains groups
  collect() |> 
  mutate(
    across(contains("AreaCode"), str_trim),
    gear = if_else(GearCode %in% c(10,41), "line", "net"),
  ts = case_when(
    LandingMonth < 7 ~ 1,
    LandingMonth == 7 ~ 2,
    LandingMonth == 8 ~ 3,
    LandingMonth == 9 ~ 4,
    LandingMonth > 9 ~ 5
    )
  )

DBI::dbDisconnect(con_ft)

rm(con_ft)

saveRDS(ft_pull, "temp_ft_pull.rds")
```

```{r}
ft_pull <- readRDS("temp_ft_pull.rds")

ft_pull |> 
  #distinct(CatchAreaCode, CatchAreaDescription, FisherTypeDescription, GearCode, gear) |> writexl::write_xlsx("temp_fishtix.xlsx")
  group_by(year = BatchYear, CatchAreaCode, CatchAreaDescription, FisherTypeDescription, gear, ts) |> 
  summarise(rc = sum(rc), .groups = "drop") 

mutate(
  FisheryID = case_when(
    ~ 34, #A1-Ast Trl	WA Area 1 & Astoria Troll
    ~ 35, #Area2Trl NT	WA Area 2 Non-Treaty Troll
    ~ 36, #Area2TrlTR	WA Area 2 Treaty Troll
    ~ 38, #WA Area 3 Non-Treaty troll
    ~ 39, #WA Area 3 Treaty troll
    ~ 42,	#A4/4BTrlNT	WA Area 4/4B Non-Treaty Troll
    ~ 43,	#A4/4BTrlTR	WA Area 4/4B Treaty Troll
    ~ 44, #A5-6C Trl	WA Area 5-6-6C Troll; all Treaty troll
    ~ 47, #WlpaBT Net	Willapa Bay & FW Trib Net; all 22-14, Non-treaty Drift Gillnet
    
    CatchAreaCode & FisherTypeDescription  ~ 50, #GryHbr Net	Grays Harbor Estuary Net; all NT drift gillnet
    
    CatchAreaCode & FisherTypeDescription  ~ 52, #LwCheh Net	Lower Chehalis R Net
    CatchAreaCode & FisherTypeDescription  ~ 55, #Hump R Net	Humptulips R Net
    CatchAreaCode & FisherTypeDescription  ~ 56, #UpCheh Net	Upper Chehalis R Net
    CatchAreaCode & FisherTypeDescription  ~ 63, #Quin R Net	Quinault R Net
    CatchAreaCode & FisherTypeDescription  ~ 68, #Queets Net	Queets R Net
    CatchAreaCode & FisherTypeDescription  ~ 71, #Quilly Net	Quillayute R Net; should this get the 770 Sol Duc R recs?
    CatchAreaCode & FisherTypeDescription  ~ 74, #Hoh R  Net	Hoh R Net
    CatchAreaCode & FisherTypeDescription  ~ 77, #Mak FW Net	Makah Freshwater Net
    CatchAreaCode & FisherTypeDescription ~ 79,	#A 4-4A Net	WA Area 4-4A Net
    CatchAreaCode & FisherTypeDescription  ~ 80, #A4B6CNetNT	WA Area 4B-5-6C Non-Treaty Net; not assigned 23-16 Set Gillnet, 23-52 Mixed Net
    CatchAreaCode & FisherTypeDescription  ~ 81, #A4B6CNetTR	WA Area 4B-5-6C Treaty Net; assigned 23-16 Set Gillnet, 23-52 Mixed Net
    CatchAreaCode & FisherTypeDescription  ~ 82, #Ar6D NetNT	6D Non-Treaty Net (Dungeness Bay & R); no FW net recs with "DUNGENESS" in name
    CatchAreaCode & FisherTypeDescription  ~ 83, #Ar6D NetTR	6D Treaty Net (Dungeness Bay & R); no FW net recs with "DUNGENESS" in name
    
    CatchAreaCode & FisherTypeDescription  ~ 84, #Elwha  Net	Elwha R Net
    CatchAreaCode & FisherTypeDescription ~ 85,	#WJDF T Net	West JDF Straits Trib Net
    CatchAreaCode & FisherTypeDescription ~ 86,	#EJDF T Net	East JDF Straits Trib Net
    CatchAreaCode & FisherTypeDescription  ~ 87, #A6-7ANetNT	WA Area 7-7A Non-Treaty Net
    CatchAreaCode & FisherTypeDescription  ~ 88, #A6-7ANetTR	WA Area 7-7A Treaty Net
    
    CatchAreaCode & FisherTypeDescription ~ # 96	A7BCDNetNT	WA Area 7B-7C-7D Non-Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 97	A7BCDNetTR	WA Area 7B-7C-7D Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 98	Nook R Net	Nooksack R Net
      CatchAreaCode & FisherTypeDescription ~ # 101	Ar 8 NetNT	WA Area 8 Non-Treaty Net (Skagit)
      CatchAreaCode & FisherTypeDescription ~ # 102	Ar 8 NetTR	WA Area 8 Treaty Net (Skagit)
      CatchAreaCode & FisherTypeDescription ~ # 103	Skag R Net	Skagit R Net
      CatchAreaCode & FisherTypeDescription ~ # 104	SkgR TsNet	Skagit River Test Net
      CatchAreaCode & FisherTypeDescription ~ # 105	SwinCh Net	Swinomish Channel Net
      CatchAreaCode & FisherTypeDescription ~ # 109	Ar8A NetNT	WA Area 8A Non-Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 110	Ar8A NetTR	WA Area 8A Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 111	Ar8D NetNT	WA Area 8D Non-Treaty Net (Tulalip Bay)
      CatchAreaCode & FisherTypeDescription ~ # 112	Ar8D NetTR	WA Area 8D Treaty Net (Tulalip Bay)
      CatchAreaCode & FisherTypeDescription ~ # 113	Stil R Net	Stillaguamish R Net
      CatchAreaCode & FisherTypeDescription ~ # 114	Snoh R Net	Snohomish R Net
      CatchAreaCode & FisherTypeDescription ~ # 119	Ar10 NetNT	WA Area 10 Non-Treaty Net (Seattle)
      CatchAreaCode & FisherTypeDescription ~ # 120	Ar10 NetTR	WA Area 10 Treaty Net (Seattle)
      CatchAreaCode & FisherTypeDescription ~ # 121	Ar10ANetNT	WA Area 10A Non-Treaty Net (Elliott Bay)
      CatchAreaCode & FisherTypeDescription ~ # 122	Ar10ANetTR	WA Area 10A Treaty Net (Elliott Bay)
      CatchAreaCode & FisherTypeDescription ~ # 123	Ar10ENetNT	WA Area 10E Non-Treaty Net (East Kitsap)
      CatchAreaCode & FisherTypeDescription ~ # 124	Ar10ENetTR	WA Area 10E Treaty Net (East Kitsap)
      CatchAreaCode & FisherTypeDescription ~ # 125	10F-G  Net	WA Area 10F-G Treaty Net (Lake Union)
      CatchAreaCode & FisherTypeDescription ~ # 126	Duwm R Net	Green/Duwamish R Net
      CatchAreaCode & FisherTypeDescription ~ # 130	Ar11 NetNT	WA Area 11 Non-Treaty Net (E/W Pass)
      CatchAreaCode & FisherTypeDescription ~ # 131	Ar11 NetTR	WA Area 11 Treaty Net (E/W Pass)
      CatchAreaCode & FisherTypeDescription ~ # 132	Ar11ANetNT	WA Area 11A Non-Treaty Net (Comm. Bay)
      CatchAreaCode & FisherTypeDescription ~ # 133	Ar11ANetTR	WA Area 11A Treaty Net (Comm. Bay)
      CatchAreaCode & FisherTypeDescription ~ # 134	Puyl R Net	Puyallup R Net
      CatchAreaCode & FisherTypeDescription ~ # 137	Ar13 NetNT	Area 13 Non-Treaty Net (So Puget Sound)
      CatchAreaCode & FisherTypeDescription ~ # 138	Ar13 NetTR	Area 13 Treaty Net (So Puget Sound)
      CatchAreaCode & FisherTypeDescription ~ # 139	Ar13CNetNT	Area 13C Non-Treaty Net (Chambers Bay)
      CatchAreaCode & FisherTypeDescription ~ # 140	Ar13CNetTR	Area 13C Treaty Net (Chambers Bay)
      CatchAreaCode & FisherTypeDescription ~ # 141	Ar13ANetNT	Area 13A Non-Treaty Net (Carr Inlet)
      CatchAreaCode & FisherTypeDescription ~ # 142	Ar13ANetTR	Area 13A Treaty Net (Carr Inlet)
      CatchAreaCode & FisherTypeDescription ~ # 143	Ar13DNetNT	Area 13D Non-Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 144	Ar13DNetTR	Area 13D Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 145	A13FKNetNT	Area 13F-13K Non-Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 146	A13FKNetTR	Area 13F-13K Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 147	Nisq R Net	Nisqually R Net
      CatchAreaCode & FisherTypeDescription ~ # 148	McAlls Net	McAllister Creek Net
      CatchAreaCode & FisherTypeDescription ~ # 153	1212BNetNT	Area 12-12B Hood Canal Non-Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 154	1212BNetTR	Area 12-12B Hood Canal Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 155	A9-9ANetNT	Area 9/9A Non-Treaty Net
      CatchAreaCode & FisherTypeDescription ~ # 156	A9-9ANetTR	Area 9/9A Treaty Net (On Res)
      CatchAreaCode & FisherTypeDescription ~ # 157	Ar12ANetNT	Area 12A Non-Treaty Net (Quilcene Bay)
      CatchAreaCode & FisherTypeDescription ~ # 158	Ar12ANetTR	Area 12A Treaty Net (Quilcene Bay)
      CatchAreaCode & FisherTypeDescription ~ # 159	A12CDNetNT	Area 12C-12D Non-Treaty Net (SE Hood Canal)
      CatchAreaCode & FisherTypeDescription ~ # 160	A12CDNetTR	Area 12C-12D Treaty Net (SE Hood Canal)
      CatchAreaCode & FisherTypeDescription ~ # 161	Skok R Net	Skokomish R Net
      CatchAreaCode & FisherTypeDescription ~ # 162	Quilcn Net	Quilcene R Net
      
  )
)
```


# CWTs


## FRAM fishery assignment

 - RMIS - Tagged Releases
 - Recoveries by Tag Code
 - Tag Status = 1
 - Species = 2 (coho)
 - Recovery Year = ...

MB create `clip_status` == 1 as `between(cwt_1st_mark, 5000, 6000)`
Drop sample_type == 5
Create rec_month from date; loses a trace number of recent records to malformed dates, could fix up
MB escapement separating out C&S, so `fishery %in% c(50:54,57:59)`, excluding RMIS 55 & 56


```{r}
# #MB wrangled rec-rel, silly big file
# mb20$cwt_prefram <- readr::read_csv("O:/code/coho/rrterm/MB_Draft_2020/Data_ProcessingSteps/Fishery_Method_Files_CWT/rec10_4merge_121621.csv")

#still silly big number of columns, here not bothering to avoid .x/.y duplicates
mb20$cwt_raw <- left_join(
  readr::read_csv("O:/code/coho/rrterm/MB_Draft_2020/Data_ProcessingSteps/Raw_RMIS_CWTQueryData/Recovery_Data_121621/CSV6559.csv")
  ,
  readr::read_csv("O:/code/coho/rrterm/MB_Draft_2020/Data_ProcessingSteps/Raw_RMIS_CWTQueryData/Release_Data_121621/CSV6205.csv")
  ,
  by = c("tag_code" = "tag_code_or_release_id",
         "brood_year" = "brood_year")
  ) |> 
  select(-ends_with(".y"))


rmis_rr <- mb20$cwt_raw |> 
  filter(
    sample_type != 5,
    (fishery < 50 | fishery %in% 55:56 | fishery > 59)
  ) |> 
  mutate(
    rec_date = as.Date(as.character(recovery_date), format = "%Y%m%d"),
    rec_year = lubridate::year(rec_date),
    rec_month = lubridate::month(rec_date),
    ts = case_when(
      rec_month %in% 1:6 ~ 1,
      rec_month == 7 ~ 2,
      rec_month == 8 ~ 3,
      rec_month == 9 ~ 4,
      rec_month %in% 10:12 ~ 5),
    fishery_single = floor(fishery/10)
  ) |> 
  #count(run_year, rec_year) #vast majority of recovery_date years match run_year
  select(starts_with("rec_"), ts, recovery_location_code, fishery, fishery_single, gear, estimated_number, cwt_1st_mark) |> 
  tibble::rowid_to_column("uid") 

  
#first declare temp object of only key fields
rmis_rr_to_map <- select(.data = rmis_rr, uid, recovery_location_code, fishery_single)

#now overwrite as split-then-bind pattern on Num_Chars
#per AHB request, added explicit right string padding to specified string length
#even when actual strings in RMIS and LU are/use fewer char
rmis_rr_to_map <- map_df(
  sort(unique(lu$rmis_fram_fishery$Num_Chars)),
  ~inner_join(
    rmis_rr_to_map |> 
      mutate(
        PSC_Code = str_sub(recovery_location_code, 1, .x) |> 
          str_pad(width = .x, side = "right")
        )
    ,
    lu$rmis_fram_fishery |> 
      filter(Num_Chars == .x) |> 
      mutate(
        PSC_Code = str_pad(PSC_Code, width = .x, side = "right")
        )
    ,
    by = c("PSC_Code", "fishery_single")
  )
)

#now rejoin to full dataset, after making FisheryID distinct per UID
rmis_rr <- left_join(
  rmis_rr, 
  #split out any multiple-mapped, make distinct per UID and rebind
  bind_rows(
    #records that map to a single fishery
    anti_join(
      rmis_rr_to_map
      ,
      rmis_rr_to_map |> count(uid) |> filter(n>1) |> select(uid)
      , by = "uid"
      ) |> 
      select(uid, FisheryID)
    ,
    #MAY BE 0 ROWS records that map to multiple fisheries
    semi_join(
      rmis_rr_to_map
      ,
      rmis_rr_to_map |> count(uid) |> filter(n>1) |> select(uid)
      ,
      by = "uid"
      ) |> 
      group_by(uid) |> 
      slice_max(Num_Chars, n = 1, with_ties = F) |> 
      ungroup() |> 
      select(uid, FisheryID)
  )
  ,
  by = "uid"
  )

#unmapped recoveries
rmis_rr |> 
  filter(is.na(FisheryID)) |> 
  count(recovery_location_code) |> 
  print(n=100)
#bad dates Indy (look all RMIS 2Canadian and 7other for 2018-2020 test set)
rmis_rr |> 
  filter(is.na(rec_date)) |> 
  count(recovery_location_code) |> 
  print(n=100)

#Non-stock aggregation
rmis_rr |> 
  drop_na(FisheryID, rec_date, estimated_number) |> 
  inner_join(lu$fram_ca, by = "FisheryID") |> 
  drop_na(RRTermType) |> 
  filter(ts > 2) |> 
  #group_by(year = rec_year, FisheryID, CA_Number, CA_Short_Name, CWT_Flag, Cat_Flag, Type_Calc, RRTermType, ts) |> 
  group_by(year = rec_year, CA_Number, CA_Short_Name, CWT_Flag, Cat_Flag, Type_Calc, RRTermType, ts) |> 
  summarise(estimated_number = sum(estimated_number), .groups = "drop") |> 
  arrange(year, CA_Number, ts) |> 
  pivot_wider(names_from = ts, values_from = estimated_number, values_fill = 0) |> 
  mutate(
    estimated_number = case_when(
      RRTermType == "FW" ~ `3` + `4` + `5`,
      RRTermType == "M" ~ `4` + `5`
    )
  ) |> 
  filter(year == 2020)

#next, migrate the "STOCK_METHOD" elements to reach something with MU_Short_Name
#can maybe add actual PR_MU?
read_csv("O:/code/coho/rrterm/MB_Draft_2020/RRTerm_Automated_DataInputs/CWT_Rec_4OldRRTerm_RegularTS_010422_20onlyrv.csv")

```


# Run reconstruction 


```{r}
  #when full set of catches associated to CAs, then associate stock units per fishery/CA
  inner_join(lu$ca_pr_mu, by = c("CA_Number", "CA_Short_Name")) |> 
  #and then escp, tocas, etc.
  inner_join(data_in$escp |> select(year, PR_MU, escp), by = c("year", "PR_MU")) |> 
  group_by(year, FisheryID, CA_Number) |> 
  mutate(
    pct_escp = escp / sum(escp),
    catchest_pct_escp = catchest * pct_escp
    ) |> 
  group_by(year, PR_MU, MU_Short_Name) |> 
  summarise(escp = first(escp), crc = sum(catchest_pct_escp), .groups = "drop")

```


to set up first deducting CWT*PEF then splitting remainder by escp_pct

```{r hvst_cwt_pef_escp}
#begin with catch estimates
hvst_cwt_pef_escp <- rr$hvst |> 
  filter(Run_ID == 2019) |> 
  #join potential PR_MUs within CAs
  #fixing Baker MU_Short_Name on the fly
  left_join(
    rr$lu_ca_mu |> 
      mutate(
        MU_Short_Name = if_else(PR_Number == 2 & PR_MU_Number == 3, "skgbkw", MU_Short_Name),
        MU_Short_Name = if_else(PR_Number == 2 & PR_MU_Number == 4, "skgbkh", MU_Short_Name)
      ) #|> filter(PR_Number == 2, between(PR_MU_Number, 3, 4)) |> count(PR_Number, PR_MU_Number, MU_Short_Name)
    ,
    by = "CA_Number") |> 
  #join CWT*PEF values
  left_join(
    #may need/want to pre-filter down the full_join before left_join?
    full_join(
      rr$cwt, #just MU_Short_Name, no PR_Number+PR_MU_Number...
      rr$pef, 
      by = c("Run_ID", "MU_Short_Name"),
      suffix = c("_cwt", "_pef")
      ) |> 
      mutate(cwt_pef = CWT_Est_Rec * Local_PEF)
    , 
    by = c("Run_ID", "CA_Number", "PR_Number", "PR_MU_Number", "MU_Short_Name")
    ) |> 
  #join escapement estimates
  left_join(rr$escp, by = c("Run_ID", "PR_Number", "PR_MU_Number", "MU_Short_Name")) |> 
  arrange(Run_ID, CA_Number, PR_Number, PR_MU_Number) |> 
  #drop a few cols for easier dev
  select(-ends_with("_CV"))
```


```{r }
# #do anything with these?
# #cells are highlighted in xlsx, but values are not cwt_pef...
# hvst_cwt_pef_escp |> filter(Flag_cwt == 0)

hvst_cwt_pef_escp |> 
  #back join total CWT*PEF across MUs per CA
  left_join(
    hvst_cwt_pef_escp |> 
      filter(Flag_cwt == 1) |> 
      group_by(Run_ID, CA_Number) |> 
      summarise(cwt_pef_sum = sum(cwt_pef), .groups = "drop")
    , by = c("Run_ID", "CA_Number")
    ) |>
  #deduct expanded CWT catch if exists
  mutate(
    catch_cwt_pef_sum = if_else(
      is.na(cwt_pef_sum), 
      Catch, 
      Catch - cwt_pef_sum
      )
  ) |>
  #assign remainder by relative escapement abundance
  group_by(Run_ID, CA_Number) |> 
  mutate(
    escp = if_else(is.na(HR_Flag), 0, Escapement),
    escp = if_else(!is.na(Flag_cwt) & Flag_cwt == 1, 0, escp),
    
    pr_mu_pct = escp / sum(escp, na.rm = T),
    catch_pct = catch_cwt_pef_sum * pr_mu_pct,
    catch_final = if_else(
      !is.na(Flag_cwt) & Flag_cwt == 1,
      cwt_pef,
      catch_pct
      )
    ) |> 
  ungroup() |> 
  left_join(rr$run_calc_saved |> 
              select(Run_ID, PR_Number, CA_Number, PR_MU_Number, run_calc_catch = Catch),
            by = c("Run_ID", "PR_Number", "CA_Number", "PR_MU_Number")) |> 
  mutate(
    d = run_calc_catch - catch_final
  ) |> 
  # #filter(PR_Number == 6) |> 
  # #filter(PR_Number == 1) |> 
  # #filter(d != 0) |> 
  filter(abs(d) > 1) |>
  print(n=40)
  #writexl::write_xlsx("demo_rr_coho_2019_QAQC.xlsx")

```

